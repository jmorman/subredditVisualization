<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Subreddit Visualization</title>
		<link rel="stylesheet" href="svstyle.css">
        <!-- <script type="text/javascript" src="/usr/share/javascript/d3/d3.js"></script> -->
        <script type="text/javascript" src="../d3/d3.v3.js"></script>
    </head>
    <body>
        <script type="text/javascript">

			var w = 1000;
			var h = 300;
			var wlPadding = 50;
			var wrPadding = 300;
			var hPadding = 30;
			var dataset = [];

			var svg = d3.select("body")
					.append("svg")
					.attr("width", w)
					.attr("height", h);

			// Load iris dataset. Makes array of objects, each object containing info in a row
			// second argument is an anonymous function which is called after attempting to
			//	load the data
			d3.csv("iris.csv", function(error, data) {
				if (error) {  
          			console.log(error);  //Log the error.
        		} else {      
          			dataset=data;
					irisFunction();
				}
			});
			
			var irisFunction = function(){

				var features = {petal_width: true, 
								petal_length: true, 
								sepal_length: true, 
								sepal_width: true};

				var actives = activeFeatures(features);
				var all = Object.keys(features);

				var [xScale, yScale] = makeScales(features);

				drawLineChart(xScale, yScale, features);
				drawAxes(xScale, yScale);

				//write out iris data for convenience
				//writeData();
				for (var i = 0; i < all.length; i++){
					svg.append("text")
						.attr("x", w - wrPadding * 0.75)
						.attr("y", 0.85 * h / all.length * (i + 1))
						.attr("id", "button_" + all[i])
						.style("color", "black")
						.text("Toggle " + all[i])
						.on('click', function(){ 
							prefixLength = "button_".length;
							targetFeature = this.id.slice(prefixLength, this.id.length);
							if(features.hasOwnProperty(targetFeature)){
								//toggle activate/deactivate corresponding line graph
								features[targetFeature] = !features[targetFeature];
								[xScale, yScale] = makeScales(features);
								drawAxes(xScale, yScale);
								drawLineChart(xScale, yScale, features);
							}
						});
				}

			}

			var activeFeatures = function(feats){
				result = [];
				for (feat in feats){
					if(feats[feat]){
						result.push(feat);
					}				
				}
				return result;
			}
		
			var makeScales = function(feats){
				maxes = []
				for (feat in feats){
					if(feats[feat]){
						featMax = d3.max(dataset, function(d) { return d[feat]; });
						maxes.push(featMax);
					}
				}
				//spread operator
				maximum = Math.max(...maxes);

				var xscl = d3.scale.linear()
								.domain([0, dataset.length])
								.range([wlPadding, w - wrPadding]);

				var yscl = d3.scale.linear()
								.domain([0, maximum])
								.range([h - hPadding, hPadding]);
				

				return [xscl, yscl];
			}
		
			var getRandomColor = function(){
				return "rgb(" + (Math.floor(Math.random() * 256)) + "," + (Math.floor(Math.random() 						* 256)) + "," + (Math.floor(Math.random() * 256)) + ")";
			}

			var drawLineChart = function(xscl, yscl, feats){
				for (feat in feats){
					//if feature should be charted,
					if(feats[feat]){

						//d3.svg.line() is a helper class for generating path data.
						//"Each generator is a function of data"
						var line = d3.svg.line()
							.x(function(d, i) { return xscl(i); })
							.y(function(d) { return yscl(d[feat]); })
							//.interpolate("linear");
							.interpolate("basis");

						//and if feature is not charted,
						if(d3.select("#line_" + feat).empty()){
							
							//then chart it:
							color = getRandomColor();

							svg.append("path")
								.attr("d", line(dataset))
								.attr("stroke", color)
								.attr("stroke-width", 2)
								.attr("id", "line_" + feat)
								.attr("class", "line")
								.attr("fill", "none");
						}
						
						//if feature is charted,
						else{
							//update according to new scale
							d3.select("#line_" + feat)
								.transition()
								.duration(500)
								.attr("d", line(dataset));
						}
					}
					//if feature should not be charted,
					else{
						//but feature is charted,
						if(!d3.select("#line_" + feat).empty()){
							//then remove it:
							d3.select("#line_" + feat).remove();
						}
					}
				}
			}

			var drawAxes = function(xscl, yscl){

				//Define X axis
				var xAxis = d3.svg.axis()
							  .scale(xscl)
							  .orient("bottom")
							  .ticks(10);

				//Define Y axis
				var yAxis = d3.svg.axis()
							  .scale(yscl)
							  .orient("left")
							  .ticks(10);
				if(svg.select("#x_axis").empty()){
					//Create X axis
					svg.append("g")
						.attr("class", "axis")
						.attr("id", "x_axis")
						.attr("transform", "translate(0," + (h - hPadding) + ")")
						.call(xAxis);
			
					//Create Y axis
					svg.append("g")
						.attr("class", "axis")
						.attr("id", "y_axis")
						.attr("transform", "translate(" + wlPadding + ",0)")
						.call(yAxis);
				}
				else {
					svg.select("#x_axis")
						.transition()
						.duration(500)
						.call(xAxis);

					svg.select("#y_axis")
						.transition()
						.duration(500)
						.call(yAxis);
				}
			}

			/*var writeData = function(){

				//write out iris data for convenience
				d3.select("body").selectAll("p")
				.data(dataset)
				.enter()
				.append("p")
				.text(function(d) {
					return JSON.stringify(d);
				});

			}*/

        </script>
    </body>
</html>
