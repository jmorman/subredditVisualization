<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Subreddit Visualization</title>
		<link rel="stylesheet" href="svstyle.css">
        <!-- <script type="text/javascript" src="/usr/share/javascript/d3/d3.js"></script> -->
        <script type="text/javascript" src="../d3/d3.v3.js"></script>
    </head>
    <body>
        <script type="text/javascript">

			var w = 1000;
			var h = 300;
			var wlPadding = 50;
			var wrPadding = 300;
			var hPadding = 30;
			var dataset = [];

			var svg = d3.select("body")
					.append("svg")
					.attr("width", w)
					.attr("height", h);

			// Load iris dataset. Makes array of objects, each object containing info in a row
			// second argument is an anonymous function which is called after attempting to
			//	load the data
			d3.csv("iris.csv", function(error, data) {
				if (error) {  
          			console.log(error);  //Log the error.
        		} else {      
          			dataset=data;
					irisFunction();
				}
			});
			
			var irisFunction = function(){

				var features = {petal_width: true, 
								petal_length: true, 
								sepal_length: true, 
								sepal_width: true};

				var actives = activeFeatures(features);
				var all = Object.keys(features);

				var scales = makeScales(actives);
				var xScale = scales[0];
				var yScale = scales[1];

				drawLineChart(xScale, yScale, features);
				drawAxes(xScale, yScale);

				//write out iris data for convenience
				//writeData();
				for (var i = 0; i < all.length; i++){
					svg.append("text")
						.attr("x", w - wrPadding * 0.75)
						.attr("y", 0.85 * h / all.length * (i + 1))
						.attr("id", "button_" + all[i])
						.style("color", "black")
						.text("Toggle " + all[i])
						.on('click', function(){ 
							prefixLength = "button_".length;
							targetFeature = this.id.slice(prefixLength, this.id.length);
							if(features.hasOwnProperty(targetFeature)){
								features[targetFeature] = !features[targetFeature];
								drawLineChart(xScale, yScale, features);
							}
						});
				}

			}

			var activeFeatures = function(feats){
				result = [];
				for (feat in feats){
					if(feats[feat]){
						result.push(feat);
					}				
				}
				return result;
			}
		
			var makeScales = function(feats){
				maxes = []
				for (var i = 0; i < feats.length; i++){
					featMax = d3.max(dataset, function(d) { return d[feats[i]]; });
					maxes.push(featMax);
				}

				//spread operator
				max = Math.max(...maxes);

				for (var i = 0; i < feats.length; i++){
					var xscl = d3.scale.linear()
									 .domain([0, dataset.length])
									 .range([wlPadding, w - wrPadding]);

					var yscl = d3.scale.linear()
									 .domain([0, max])
									 .range([h - hPadding, hPadding]);
				}

				return [xscl, yscl];
			}

			var drawLineChart = function(xscl, yscl, feats){
				var color = "rgb(" + (Math.floor(Math.random() * 256)) + "," + (Math.floor(Math.random() 						* 256)) + "," + (Math.floor(Math.random() * 256)) + ")";
				for (feat in feats){
					//if feature should be charted,
					if(feats[feat]){
						//and if feature is not charted,
						if(d3.select("#line_" + feat).empty()){
							//then chart it:
							color = "rgb(" + (Math.floor(Math.random() * 256)) + "," + 										(Math.floor(Math.random() * 256)) + "," + 										(Math.floor(Math.random() * 256)) + ")";
							//d3.svg.line() is a helper class for generating path data.
							//"Each generator is a function of data"
							var line = d3.svg.line()
								.x(function(d, i) { return xscl(i); })
								.y(function(d) { return yscl(d[feat]); })
								//.interpolate("linear");
								.interpolate("basis");

							svg.append("path")
								.attr("d", line(dataset))
								.attr("stroke", color)
								.attr("stroke-width", 2)
								.attr("id", "line_" + feat)
								.attr("class", "line")
								.attr("fill", "none");
						}
					}
					//if feature should not be charted,
					else{
						//but feature is charted,
						if(!d3.select("#line_" + feat).empty()){
							//then remove it:
							console.log("line_" + feat);
							d3.select("#line_" + feat).remove();
						}
					}
				}
			}

			var drawAxes = function(xscl, yscl){

				//Define X axis
				var xAxis = d3.svg.axis()
							  .scale(xscl)
							  .orient("bottom")
							  .ticks(10);

				//Define Y axis
				var yAxis = d3.svg.axis()
							  .scale(yscl)
							  .orient("left")
							  .ticks(10);
				//Create X axis
				svg.append("g")
					.attr("class", "axis")
					.attr("transform", "translate(0," + (h - hPadding) + ")")
					.call(xAxis);
			
				//Create Y axis
				svg.append("g")
					.attr("class", "axis")
					.attr("transform", "translate(" + wlPadding + ",0)")
					.call(yAxis);
			}

			/*var writeData = function(){

				//write out iris data for convenience
				d3.select("body").selectAll("p")
				.data(dataset)
				.enter()
				.append("p")
				.text(function(d) {
					return JSON.stringify(d);
				});

			}*/

        </script>
    </body>
</html>
