<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Subreddit Visualization</title>
		<link rel="stylesheet" href="svstyle.css">
        <!-- <script type="text/javascript" src="/usr/share/javascript/d3/d3.js"></script> -->
        <script type="text/javascript" src="../d3/d3.v3.js"></script>
    </head>
    <body>

		<input type="text" name="query" id="query">
		<button type="button" onclick="retrieveText('query');">Show feature</button>

        <script type="text/javascript">

			
			var w = 1000;
			var h = 300;
			var wlPadding = 50;
			var wrPadding = 300;
			var hPadding = 30;
			var dataset = [];
			var features = {petal_width: false, 
							petal_length: false, 
							sepal_length: false, 
							sepal_width: false};
			var acceptQueries = false;
			var svg = d3.select("body")
					.append("svg")
					.attr("width", w)
					.attr("height", h);

			// Load iris dataset. Makes array of objects, each object containing info in a row
			// second argument is an anonymous function which is called after attempting to
			//	load the data
			d3.csv("iris.csv", function(error, data) {
				if (error) {  
          			console.log(error);  //Log the error.
        		} else {      
          			dataset=data;
					irisFunction();
				}
			});
			
			var irisFunction = function(){
				acceptQueries = true;

				var [xScale, yScale] = makeScales(features);

				//drawLineChart(xScale, yScale, features);
				drawAxes(xScale, yScale);
			}

			var retrieveText = function(id){
				if(acceptQueries){
					var textBox = document.getElementById(id);
					var value = textBox.value;
					console.log(value);
					//pseudocode:
					if(features.hasOwnProperty(value)){
						features[value] = true;
						[xScale, yScale] = makeScales(features);
						drawAxes(xScale, yScale);
						drawLineChart(xScale, yScale, features);
						addRemoveButton(value);
					}
				}
				else {
					console.log("Not accepting queries yet!");
				}
			}

			var addRemoveButton = function(feature){
				svg.append("text")
					.attr("x", w - wrPadding * 0.75)
					.attr("y", 0.85 * h / activeFeatures(features).length)
					.attr("id", "button_" + feature)
					.style("color", "black")
					.text("Remove " + feature)
					.on('click', function(){ 
						features[feature] = false;
						[xScale, yScale] = makeScales(features);
						drawAxes(xScale, yScale);
						drawLineChart(xScale, yScale, features);
						this.remove();
					});				
			}

			var activeFeatures = function(feats){
				result = [];
				for (feat in feats){
					if(feats[feat]){
						result.push(feat);
					}				
				}
				return result;
			}
		
			var makeScales = function(feats){
				maxes = []
				for (feat in feats){
					if(feats[feat]){
						featMax = d3.max(dataset, function(d) { return d[feat]; });
						maxes.push(featMax);
					}
				}
				//spread operator
				maximum = Math.max(...maxes);

				var xscl = d3.scale.linear()
								.domain([0, dataset.length])
								.range([wlPadding, w - wrPadding]);

				var yscl = d3.scale.linear()
								.domain([0, maximum])
								.range([h - hPadding, hPadding]);
				

				return [xscl, yscl];
			}
		
			var getRandomColor = function(){
				return "rgb(" + (Math.floor(Math.random() * 256)) + "," + (Math.floor(Math.random() 						* 256)) + "," + (Math.floor(Math.random() * 256)) + ")";
			}

			var drawLineChart = function(xscl, yscl, feats){
				for (feat in feats){
					//if feature should be charted,
					if(feats[feat]){
						//d3.svg.line() is a helper class for generating path data.
						//"Each generator is a function of data"
						var line = d3.svg.line()
							.x(function(d, i) { return xscl(i); })
							.y(function(d) { return yscl(d[feat]); })
							//.interpolate("linear");
							.interpolate("basis");

						//and if feature is not charted,
						if(d3.select("#line_" + feat).empty()){
							//then chart it:
							color = getRandomColor();

							svg.append("path")
								.attr("d", line(dataset))
								.attr("stroke", color)
								.attr("stroke-width", 2)
								.attr("id", "line_" + feat)
								.attr("class", "line")
								.attr("fill", "none");
						}
						
						//if feature is charted,
						else{
							//update according to new scale
							d3.select("#line_" + feat)
								.transition()
								.duration(500)
								.attr("d", line(dataset));
						}
					}
					//if feature should not be charted,
					else{
						//but feature is charted,
						if(!d3.select("#line_" + feat).empty()){
							//then remove it:
							d3.select("#line_" + feat).remove();
						}
					}
				}
			}

			var drawAxes = function(xscl, yscl){

				//Define X axis
				var xAxis = d3.svg.axis()
							  .scale(xscl)
							  .orient("bottom")
							  .ticks(10);

				//Define Y axis
				var yAxis = d3.svg.axis()
							  .scale(yscl)
							  .orient("left")
							  .ticks(10);
				if(svg.select("#x_axis").empty()){
					//Create X axis
					svg.append("g")
						.attr("class", "axis")
						.attr("id", "x_axis")
						.attr("transform", "translate(0," + (h - hPadding) + ")")
						.call(xAxis);
			
					//Create Y axis
					svg.append("g")
						.attr("class", "axis")
						.attr("id", "y_axis")
						.attr("transform", "translate(" + wlPadding + ",0)")
						.call(yAxis);
				}
				else {
					svg.select("#x_axis")
						.transition()
						.duration(500)
						.call(xAxis);

					svg.select("#y_axis")
						.transition()
						.duration(500)
						.call(yAxis);
				}
			}

			/*var writeData = function(){

				//write out iris data for convenience
				d3.select("body").selectAll("p")
				.data(dataset)
				.enter()
				.append("p")
				.text(function(d) {
					return JSON.stringify(d);
				});

			}*/

        </script>
    </body>
</html>
